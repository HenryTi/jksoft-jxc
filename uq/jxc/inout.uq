ID IOQueue (
    id MINUTE,
    KEY endPoint ID, -- IOEndPoint,
    -- KEY base ID,                -- phrase of IN and OUT
    KEY id,
    value JSON,
    done TINYINT,                   -- 0: 未处理，1：已完成，-1: 出错
    orgId ID,                       -- 防止重复，暂不处理
    INDEX endPoint_orgId(endPoint, orgId) UNIQUE,
);

IX IOInOut (
    i TINY,                         -- 0: out, 1: in
    x,                              -- 待处理的IOQueue id
);

IDX IODone (
    id,
    endPoint ID, -- IOEndPoint,
    result JSON,
    INDEX endPoint_id(endPoint, id) UNIQUE,
);
/*
-- 外部机构
ID IOOuter (
    id,
    KEY base ID,                -- site
    KEY id,
    no NO,
    ex EX,
    token TEXT,                 -- 访问token，许可
);

ID IOApp (
    id,
    KEY base ID,
    KEY id,
    no NO,
    ex EX,
);
*/
ENUM EnumIOState (
    ok                  = 0,
    stopped             = 1,
    errSqlProc          = 11,
    errOutConnection    = 21,
    errUnknown          = 999,
);

ID IOEndPoint (
    id,
    KEY outer ID,               -- IOOuter,
    KEY inout ID,               -- IN or OUT bizphrase id
    KEY app ID,                 -- IOApp
    -- type TINYINT,               -- 1: in, 2: push, 3: pull
    -- url CHAR(200),
    -- token TEXT,                 -- 访问token，许可。如果null，则取Outer token
    cur BIGINT DEFAULT 0,       -- 当前已经处理完成指针，指向IOQUeue
    state ENUM EnumIOState DEFAULT EnumIOState.ok,     -- 当前处理完成状态。如果不是0=正常，则停止等待。
    valid TINYINT DEFAULT 1,
    INDEX inout_id (inout, id) UNIQUE,
);

/*
ID IOAtomType (
    id,
    KEY outer ID,               -- outer
    KEY phrase ID,              -- inner atom phrase
);
*/

-- Atom: AppAtomType
-- Duo: AppAtomType <=> Atom
ID IOAtom (
    id,                         -- IO atom id
    KEY type ID,                -- DUO(outer, atomPhrase) -- IOAtomType,
    KEY atom ID,                -- outer atom no
    no NO,                      -- inner id
    INDEX type_no(type, no),
);

Biz AC BuildIOEndPoint(
    outer ID,
    app ID,
    io ID,
) {
    VAR endPoint ID;
    IF outer = 0 {
        -- app, io>0 增，io<0 减
        FOR (var outerId ID OF SELECT a.id as outerId
                FROM ATOM as a 
                    JOIN BizPhrase as b ON b.id=a.base
                WHERE b.name='$ioouter' AND b.base=$site
        ) {
            IF io>0 {
                WITH IOEndPoint ID to endPoint KEY(outerId, io, app) SET valid=1;
            }
            ELSE {
                WITH IOEndPoint KEY(outerId, -io, app) SET valid=0;
            }
        }
    }
    ELSE {
        -- outer，app>0 增，app<0 减 
        IF app>0 {
            FOR (var ioId ID OF SELECT a.x as ioId FROM Duo as a WHERE a.i=app AND a.valid=1) {
                WITH IOEndPoint ID to endPoint KEY(outer, ioId, app) SET valid=1;
            }
        }
        ELSE {
            FOR (var ioId ID OF SELECT a.x as ioId FROM Duo as a WHERE a.i=-app AND a.valid=1) {
                WITH IOEndPoint KEY(outer, ioId, -app) SET valid=0;
            }
        }
    }
}

PROC ProcessIOIn (
    batchNumber INT,            -- 批处理数量，默认1
) {
    IF batchNumber IS NULL {
        SET batchNumber=1;
    }
    VAR i INT = 0, p BIGINT = 0, id ID=0, sql CHAR(500), site ID, inout ID;
    WHILE i<batchNumber {
        SET inout=null;
        SET id=b.id, site=d.base, inout=c.inout
            FROM IOInOut as a 
                JOIN IOQueue as b ON a.i=1 AND b.id=a.x
                JOIN IOEndPoint as c ON c.id=b.endPoint
                JOIN BizPhrase as d ON d.id=c.inout
                -- JOIN IOOuter as d ON d.id=c.outer
            WHERE a.x>id
            ORDER BY a.x ASC 
            LIMIT 1;
        IF inout IS NULL { BREAK; }
        TRANS START;
        SET sql = CONCAT('call `$site`.`', site, '.', inout, '`(?);');
        ExecSql sql USING id;
        TRANS COMMIT;
        SET i=i+1;
    }
}

PROC ProcessIOOut (
    batchNumber INT,            -- 批处理数量，默认1
)
RETURNS ret (
    * IOQueue,
) {
    IF batchNumber IS NULL {
        SET batchNumber=1;
    }
    INTO ret SELECT * b
        FROM IOInOut as a JOIN IOQueue as b ON a.i=0 AND b.id=a.x
        ORDER BY a.x ASC
        LIMIT batchNumber;
}

PROC ProcessIOOutDone (
    id ID,
    result JSON,
) {
    VAR done ID, endPoint ID;
    SET endPoint=(SELECT a.endPoint FROM IOQueue as a WHERE a.id=id);
    IF endPoint IS NULL {
        RETURN;
    }
    TRANS START;
    IF result IS NOT NULL {
        WITH IODone ID=id SET endPoint=endPoint, result=result;
        SET done=2;
    }
    ELSE {
        SET done=1;
    }
    WITH IOQueue ID=id SET done=done;
    WITH IOInOut I=0 X=id DEL;
    TRANS COMMIT;
}

PROC SaveIOQueue(
    endPoint ID,
    value JSON,
    orgId ID,                   -- 防止重复
) {
    VAR id ID;
    IF NOT EXISTS(SELECT a.id FROM IOQueue as a WHERE a.endPoint=endPoint AND a.orgId=orgId) {
        WITH IOQueue ID to id KEY(endPoint) SET value=value, orgId=orgId;
    }
}

ACT SaveIOAtom (
    id ID,
    outer ID,
    phrase ID,                  -- inner atom phrase
    atom ID,                    -- inner id
    no NO,                      -- outer atom no
) 
RETURNS ret (
    id ID,
) {
    VAR ioAtomType ID = ID(Duo new KEY I=outer, X=phrase);
    IF id IS NULL {
        WITH IOAtom as a ID to id KEY(ioAtomType, atom) SET a.no=no;
    }
    ELSEIF no IS NULL {
        WITH IOAtom as a ID=id DEL;
    }
    ELSE {
        WITH IOAtom as a ID=id SET a.no=no;
    }
    INTO ret SELECT id;
}

BIZ QUERY GetIOAtoms (
    outer ID,
    phrase ID,
)
PAGE (
    atom ID ASC,
    atomNo NO,
    atomEx EX,
    no NO,
    id ID,
) {
    PAGE SELECT a.atom, c.no as atomNo, c.ex as atomEx, a.no, a.id
        FROM IOAtom as a 
            JOIN Duo as b ON b.id=a.type
            JOIN Atom as c ON c.id=a.atom
        WHERE b.i=outer AND b.x=phrase AND a.atom>$pageStart
        ORDER BY a.atom ASC
        LIMIT $pageSize;
}
