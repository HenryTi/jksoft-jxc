ID IOQueue (
    id MINUTE,
    KEY endPoint ID, -- IOEndPoint,
    -- KEY base ID,                -- phrase of IN and OUT
    KEY id,
    value JSON,
    done TINYINT,                   -- 0: 未处理，1：已完成，-1: 出错
    orgId ID,                       -- 防止重复，暂不处理
    INDEX endPoint_orgId(endPoint, orgId) UNIQUE,
);

IX IOInOut (
    i TINY,                         -- 0: out, 1: in
    x,                              -- 待处理的IOQueue id
);

IDX IODone (
    id,
    endPoint ID, -- IOEndPoint,
    result JSON,
    INDEX endPoint_id(endPoint, id) UNIQUE,
);

ENUM EnumIOState (
    ok                  = 0,
    stopped             = 1,
    errSqlProc          = 11,
    errOutConnection    = 21,
    errUnknown          = 999,
);

ID IOEndPoint (
    id,
    KEY outer ID,               -- IOOuter,
    KEY appIO ID,               -- IOApp.IO phrase id, id.base is pharse IOApp
    cur BIGINT DEFAULT 0,       -- 当前已经处理完成指针，指向IOQUeue
    state ENUM EnumIOState DEFAULT EnumIOState.ok,     -- 当前处理完成状态。如果不是0=正常，则停止等待。
    valid TINYINT DEFAULT 1,
    -- INDEX inout_id (inout, id) UNIQUE,
);

/*
ID IOAtomType (
    id,
    KEY outer ID,               -- outer
    KEY phrase ID,              -- inner atom phrase
);
*/

ID IOAppAtom (
    id,                         -- IO atom id
    KEY appID ID,               -- pharse IOApp.IO
    KEY no NO,                  -- outer app no
);

IX IOIxAtom (
    i,                          -- tonwa uq atom id
    x,                          -- ioapp atom id
);

/*
Biz AC BuildIOEndPoint(
    outer ID,
    appIO ID,           -- phrase of IOApp.IO
) {
    VAR endPoint ID;
    -- outer，app>0 增，app<0 减 
    IF app>0 {
        FOR (var ioId ID OF SELECT a.x as ioId FROM Duo as a WHERE a.i=app AND a.valid=1) {
            WITH IOEndPoint ID to endPoint KEY(outer, appIO) SET valid=1;
        }
    }
    ELSE {
        FOR (var ioId ID OF SELECT a.x as ioId FROM Duo as a WHERE a.i=-app AND a.valid=1) {
            WITH IOEndPoint KEY(outer, ioId, -app) SET valid=0;
        }
    }
}
*/
PROC ProcessIOIn (
    batchNumber INT,            -- 批处理数量，默认1
) {
    IF batchNumber IS NULL {
        SET batchNumber=1;
    }
    VAR i INT = 0, p BIGINT = 0, id ID=0, sql CHAR(500), site ID, inout ID;
    WHILE i<batchNumber {
        SET inout=null;
        SET id=b.id, site=e.base, inout=d.base
            FROM IOInOut as a 
                JOIN IOQueue as b ON a.i=1 AND b.id=a.x
                JOIN IOEndPoint as c ON c.id=b.endPoint
                JOIN BizPhrase as d ON d.id=c.appIO
                JOIN BizPhrase as e ON e.id=d.base
            WHERE a.x>id
            ORDER BY a.x ASC 
            LIMIT 1;
        IF inout IS NULL { BREAK; }
        TRANS START;
        SET sql = CONCAT('call `$site`.`', site, '.', inout, '`(?);');
        ExecSql sql USING id;
        TRANS COMMIT;
        SET i=i+1;
    }
}

PROC ProcessIOOut (
    batchNumber INT,            -- 批处理数量，默认1
)
RETURNS ret (
    * IOQueue,
) {
    IF batchNumber IS NULL {
        SET batchNumber=1;
    }
    INTO ret SELECT * b
        FROM IOInOut as a JOIN IOQueue as b ON a.i=0 AND b.id=a.x
        ORDER BY a.x ASC
        LIMIT batchNumber;
}

PROC ProcessIOOutDone (
    id ID,
    result JSON,
) {
    VAR done ID, endPoint ID;
    SET endPoint=(SELECT a.endPoint FROM IOQueue as a WHERE a.id=id);
    IF endPoint IS NULL {
        RETURN;
    }
    TRANS START;
    IF result IS NOT NULL {
        WITH IODone ID=id SET endPoint=endPoint, result=result;
        SET done=2;
    }
    ELSE {
        SET done=1;
    }
    WITH IOQueue ID=id SET done=done;
    WITH IOInOut I=0 X=id DEL;
    TRANS COMMIT;
}

PROC SaveIOQueue(
    endPoint ID,
    value JSON,
    orgId ID,                   -- 防止重复
) {
    VAR id ID;
    IF NOT EXISTS(SELECT a.id FROM IOQueue as a WHERE a.endPoint=endPoint AND a.orgId=orgId) {
        WITH IOQueue ID to id KEY(endPoint) SET value=value, orgId=orgId;
    }
}

ACT SaveIOAtom (
    id ID,
    outer ID,
    phrase ID,                  -- inner atom phrase
    atom ID,                    -- inner id
    no NO,                      -- outer atom no
) 
RETURNS ret (
    id ID,
) {
    VAR ioAtomType ID = ID(Duo new KEY I=outer, X=phrase);
    IF id IS NULL {
        WITH IOAtom as a ID to id KEY(ioAtomType, atom) SET a.no=no;
    }
    ELSEIF no IS NULL {
        WITH IOAtom as a ID=id DEL;
    }
    ELSE {
        WITH IOAtom as a ID=id SET a.no=no;
    }
    INTO ret SELECT id;
}

BIZ QUERY GetIOAtoms (
    outer ID,
    phrase ID,
)
PAGE (
    atom ID ASC,
    atomNo NO,
    atomEx EX,
    no NO,
    id ID,
) {
    PAGE SELECT a.atom, c.no as atomNo, c.ex as atomEx, a.no, a.id
        FROM IOAtom as a 
            JOIN Duo as b ON b.id=a.type
            JOIN Atom as c ON c.id=a.atom
        WHERE b.i=outer AND b.x=phrase AND a.atom>$pageStart
        ORDER BY a.atom ASC
        LIMIT $pageSize;
}
